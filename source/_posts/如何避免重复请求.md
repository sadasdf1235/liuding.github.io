---
title: 如何避免重复请求
date: 2025-01-16 15:00:00
categories:
  - 前端开发
tags:
  - JavaScript
  - Vue
  - 前端
  - Web 前端
  - 性能优化
cover: https://api.yimian.xyz/img?type=moe
---

## 为什么要避免重复请求？

在前端开发中，重复请求不仅会增加服务器负载，还可能导致数据不一致或用户体验问题。例如：

- 用户快速点击提交按钮导致重复提交表单
- 列表页面快速切换导致重复加载数据
- 接口响应慢时用户重复操作触发多次请求

## 常见解决方案

### 1. 防抖（Debounce）

防抖是指在一定时间内，只执行最后一次操作。适用于搜索框输入等场景。

```typescript
/**
 * 防抖函数
 * @param fn 需要防抖的函数
 * @param delay 延迟时间（毫秒）
 */
function debounce(fn: Function, delay: number) {
  let timer: NodeJS.Timeout | null = null

  return function (...args: any[]) {
    // 清除之前的定时器
    if (timer) clearTimeout(timer)

    // 设置新的定时器
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 使用示例
const searchInput = debounce((query: string) => {
  // 发起搜索请求
  api.search(query)
}, 300)
```

### 2. 节流（Throttle）

节流是指在一定时间内，只执行一次操作。适用于滚动加载等场景。

```typescript
/**
 * 节流函数
 * @param fn 需要节流的函数
 * @param interval 间隔时间（毫秒）
 */
function throttle(fn: Function, interval: number) {
  let lastTime = 0

  return function (...args: any[]) {
    const now = Date.now()

    if (now - lastTime >= interval) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 使用示例
const loadMore = throttle(() => {
  // 加载更多数据
  api.loadNextPage()
}, 1000)
```

### 3. 请求锁

使用标志位锁定请求状态，防止重复发送。

```typescript
class RequestLock {
  private isRequesting: boolean = false

  async request(fn: () => Promise<any>) {
    if (this.isRequesting) {
      console.log('请求正在进行中，请稍后...')
      return
    }

    try {
      this.isRequesting = true
      const result = await fn()
      return result
    } finally {
      this.isRequesting = false
    }
  }
}

// 使用示例
const lock = new RequestLock()
async function submitForm() {
  await lock.request(() => api.submit(formData))
}
```

### 4. 取消重复请求

使用 `AbortController` 取消之前的请求。

```typescript
class RequestManager {
  private controller: AbortController | null = null

  async request(url: string, options: RequestInit = {}) {
    // 取消之前的请求
    if (this.controller) {
      this.controller.abort()
    }

    // 创建新的控制器
    this.controller = new AbortController()

    try {
      const response = await fetch(url, {
        ...options,
        signal: this.controller.signal,
      })
      return await response.json()
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('请求已取消')
      }
      throw error
    }
  }
}

// 使用示例
const manager = new RequestManager()
async function fetchData() {
  const data = await manager.request('/api/data')
  // 处理数据
}
```

### 5. 使用请求缓存

对于短时间内重复的相同请求，可以使用缓存来避免重复发送。

```typescript
class CacheManager {
  private cache: Map<
    string,
    {
      data: any
      timestamp: number
    }
  > = new Map()

  private readonly CACHE_TIME = 5000 // 缓存时间5秒

  async request(key: string, fn: () => Promise<any>) {
    const cached = this.cache.get(key)
    const now = Date.now()

    // 如果缓存存在且未过期，直接返回缓存数据
    if (cached && now - cached.timestamp < this.CACHE_TIME) {
      return cached.data
    }

    // 发送新请求
    const data = await fn()

    // 更新缓存
    this.cache.set(key, {
      data,
      timestamp: now,
    })

    return data
  }
}

// 使用示例
const cacheManager = new CacheManager()
async function getData(id: string) {
  return await cacheManager.request(`data_${id}`, () => api.getData(id))
}
```

## Vue 中的实践

在 Vue 项目中，我们可以封装一个通用的请求 Hook：

```typescript
// useRequest.ts
import { ref } from 'vue'

export function useRequest<T>(requestFn: () => Promise<T>) {
  const loading = ref(false)
  const isRequesting = ref(false)

  async function execute(...args: any[]) {
    if (isRequesting.value) {
      return
    }

    try {
      loading.value = true
      isRequesting.value = true
      const result = await requestFn.apply(null, args)
      return result
    } finally {
      loading.value = false
      isRequesting.value = false
    }
  }

  return {
    loading,
    isRequesting,
    execute,
  }
}

// 使用示例
const { loading, execute } = useRequest(api.getData)
```

## 最佳实践建议

1. **选择合适的方案**

   - 输入搜索类场景使用防抖
   - 滚动加载类场景使用节流
   - 表单提交类场景使用请求锁
   - 数据查询类场景考虑使用缓存

2. **合理设置时间间隔**

   - 防抖时间建议 300-500ms
   - 节流时间根据业务场景设置
   - 缓存时间要考虑数据实时性要求

3. **错误处理**

   - 请求被取消时给出友好提示
   - 缓存策略要考虑错误情况
   - 添加适当的日志记录

4. **性能优化**
   - 及时清理过期缓存
   - 避免内存泄漏
   - 控制并发请求数量

## 总结

避免重复请求是前端开发中的重要优化点，通过合理使用：

1. 防抖和节流
2. 请求锁
3. 请求取消
4. 缓存策略

可以有效提升应用性能和用户体验。在实际开发中，需要根据具体场景选择合适的解决方案。

---

> 参考资料：
>
> 1. MDN - AbortController
> 2. Vue.js 官方文档
> 3. JavaScript 高级程序设计
