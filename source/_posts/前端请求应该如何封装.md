---
title: 前端请求应该如何封装？
date: 2025-01-17 15:30:00
categories:
  - 前端开发
tags:
  - JavaScript
  - Vue
  - 前端
  - Web 前端
  - HTTP 请求
cover: https://api.yimian.xyz/img?type=moe
---

## 为什么要封装请求？

在前端开发中，合理的请求封装可以：

1. 统一处理请求/响应拦截
2. 规范错误处理
3. 简化请求调用
4. 提高代码复用性
5. 便于维护和扩展

让我们一步步实现一个完整的请求封装方案。

## 基础封装

### 1. 创建请求实例

```typescript
// src/utils/request.ts

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'

/**
 * 创建请求实例
 */
class RequestHttp {
  // axios 实例
  private instance: AxiosInstance
  // 基础配置
  private baseConfig: AxiosRequestConfig = {
    baseURL: process.env.VUE_APP_BASE_API,
    timeout: 10000,
    headers: {
      'Content-Type': 'application/json',
    },
  }

  constructor(config?: AxiosRequestConfig) {
    // 创建实例
    this.instance = axios.create({
      ...this.baseConfig,
      ...config,
    })

    // 初始化拦截器
    this.initInterceptors()
  }

  /**
   * 初始化拦截器
   */
  private initInterceptors() {
    // 请求拦截器
    this.instance.interceptors.request.use(
      (config) => {
        // 在发送请求之前做些什么
        const token = localStorage.getItem('token')
        if (token) {
          config.headers['Authorization'] = `Bearer ${token}`
        }
        return config
      },
      (error) => {
        // 对请求错误做些什么
        return Promise.reject(error)
      }
    )

    // 响应拦截器
    this.instance.interceptors.response.use(
      (response) => {
        // 对响应数据做点什么
        const { code, data, message } = response.data

        // 根据自定义错误码判断请求是否成功
        if (code === 200) {
          return data
        }

        // 处理业务错误
        this.handleBusinessError(code, message)
        return Promise.reject(new Error(message))
      },
      (error) => {
        // 对响应错误做点什么
        this.handleNetworkError(error)
        return Promise.reject(error)
      }
    )
  }

  /**
   * 处理业务错误
   */
  private handleBusinessError(code: number, message: string) {
    switch (code) {
      case 401:
        // 未登录或token过期
        this.redirectToLogin()
        break
      case 403:
        // 权限不足
        console.error('权限不足')
        break
      default:
        console.error(message)
    }
  }

  /**
   * 处理网络错误
   */
  private handleNetworkError(error: any) {
    let message = '请求失败'
    if (error.response) {
      const status = error.response.status
      switch (status) {
        case 400:
          message = '请求错误'
          break
        case 401:
          message = '未授权，请登录'
          this.redirectToLogin()
          break
        case 403:
          message = '拒绝访问'
          break
        case 404:
          message = '请求地址出错'
          break
        case 408:
          message = '请求超时'
          break
        case 500:
          message = '服务器内部错误'
          break
        case 501:
          message = '服务未实现'
          break
        case 502:
          message = '网关错误'
          break
        case 503:
          message = '服务不可用'
          break
        case 504:
          message = '网关超时'
          break
        case 505:
          message = 'HTTP版本不受支持'
          break
        default:
          message = `未知错误${status}`
      }
    }
    console.error(message)
  }

  /**
   * 重定向到登录页
   */
  private redirectToLogin() {
    // 清除用户信息
    localStorage.removeItem('token')
    // 跳转登录页
    window.location.href = '/login'
  }

  /**
   * GET请求
   */
  public get<T = any>(
    url: string,
    params?: any,
    config?: AxiosRequestConfig
  ): Promise<T> {
    return this.instance.get(url, { params, ...config })
  }

  /**
   * POST请求
   */
  public post<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<T> {
    return this.instance.post(url, data, config)
  }

  /**
   * PUT请求
   */
  public put<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<T> {
    return this.instance.put(url, data, config)
  }

  /**
   * DELETE请求
   */
  public delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.instance.delete(url, config)
  }
}

// 导出请求实例
export const http = new RequestHttp()
```

## API 封装

### 1. 定义接口类型

```typescript
// src/types/api.ts

/**
 * 响应数据接口
 */
export interface ResponseData<T = any> {
  code: number
  data: T
  message: string
}

/**
 * 分页参数接口
 */
export interface PageParams {
  page: number
  pageSize: number
}

/**
 * 分页响应接口
 */
export interface PageResponse<T> {
  list: T[]
  total: number
  page: number
  pageSize: number
}
```

### 2. 模块化 API 管理

```typescript
// src/api/user.ts

import { http } from '@/utils/request'
import type { ResponseData } from '@/types/api'

/**
 * 用户接口
 */
export interface IUser {
  id: number
  username: string
  email: string
}

/**
 * 登录参数
 */
export interface LoginParams {
  username: string
  password: string
}

/**
 * 用户API
 */
export class UserAPI {
  /**
   * 登录
   */
  static login(params: LoginParams) {
    return http.post<ResponseData<string>>('/auth/login', params)
  }

  /**
   * 获取用户信息
   */
  static getUserInfo() {
    return http.get<ResponseData<IUser>>('/user/info')
  }

  /**
   * 更新用户信息
   */
  static updateUserInfo(data: Partial<IUser>) {
    return http.put<ResponseData<IUser>>('/user/info', data)
  }
}
```

## 使用示例

### 1. 在 Vue 组件中使用

```typescript
// src/views/Login.vue

import { defineComponent, ref } from 'vue'
import { UserAPI, type LoginParams } from '@/api/user'

export default defineComponent({
  setup() {
    const loginForm = ref<LoginParams>({
      username: '',
      password: '',
    })

    const loading = ref(false)

    const handleLogin = async () => {
      try {
        loading.value = true
        const token = await UserAPI.login(loginForm.value)
        // 保存token
        localStorage.setItem('token', token)
        // 获取用户信息
        const userInfo = await UserAPI.getUserInfo()
        // 处理用户信息...
      } catch (error) {
        console.error('登录失败:', error)
      } finally {
        loading.value = false
      }
    }

    return {
      loginForm,
      loading,
      handleLogin,
    }
  },
})
```

### 2. 使用 Composition API 封装请求逻辑

```typescript
// src/composables/useRequest.ts

import { ref } from 'vue'

interface RequestOptions {
  loading?: boolean
  onSuccess?: (data: any) => void
  onError?: (error: any) => void
}

export function useRequest<T>(
  requestFn: (...args: any[]) => Promise<T>,
  options: RequestOptions = {}
) {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<any>(null)

  const execute = async (...args: any[]) => {
    try {
      if (options.loading) {
        loading.value = true
      }

      const result = await requestFn(...args)
      data.value = result

      options.onSuccess?.(result)
      return result
    } catch (err) {
      error.value = err
      options.onError?.(err)
      throw err
    } finally {
      if (options.loading) {
        loading.value = false
      }
    }
  }

  return {
    data,
    loading,
    error,
    execute,
  }
}

// 使用示例
const {
  data: userInfo,
  loading,
  execute: fetchUserInfo,
} = useRequest(UserAPI.getUserInfo, {
  loading: true,
  onSuccess: (data) => {
    console.log('获取用户信息成功:', data)
  },
  onError: (error) => {
    console.error('获取用户信息失败:', error)
  },
})
```

## 最佳实践建议

1. **统一配置管理**

   - 使用环境变量管理 API 地址
   - 统一超时时间配置
   - 统一错误处理策略

2. **类型安全**

   - 使用 TypeScript 定义接口类型
   - 为 API 响应数据定义类型
   - 使用泛型约束请求/响应数据

3. **错误处理**

   - 统一处理网络错误
   - 统一处理业务错误
   - 提供友好的错误提示

4. **代码组织**

   - 按模块拆分 API
   - 使用类或对象组织 API 方法
   - 遵循单一职责原则

5. **性能优化**
   - 请求缓存
   - 取消重复请求
   - 并发请求控制

## 总结

一个好的请求封装应该具备：

1. 统一的接口规范
2. 完善的错误处理
3. 类型安全
4. 易于维护和扩展
5. 良好的代码组织

通过合理的请求封装，可以大大提高开发效率和代码质量。

---

> 参考资料：
>
> 1. Axios 官方文档
> 2. Vue.js 官方文档
> 3. TypeScript 官方文档
